/*Ax = b mod 2の解が何個あるかN変数で式がM個,つまり A:M*N, x:N, b:Mres = -1 -> 0個otherwise -> 2^(N-r)個ただrankを求めたい時(bがないとき) は bに関する部分を消せば良い.O(NM min(N,M) / 32)	(jのループがmin(N,M)回)verified: http://codeforces.com/contest/662/problem/C*/const int MN = ;typedef bitset<MN> Bs;typedef vector<Bs> mat;int getrank(mat A, vector<bool> b,int N){	assert(A.size() == b.size());	int M = b.size();	int res=0;	vector<bool> used(M,false);	rep(j,N){		int i = 0;		while( (i < M) && (used[i] || !A[i][j]) ) i++;		if(i == M) continue;		res++;		used[i] = 1;		rep(k,M) if(!used[k]&&A[k][j]){			A[k]^=A[i];			b[k]=b[k]^b[i];		}	}	rep(i,M) if(!used[i] && b[i] ) return -1;	return res;}typedef long long ll;bool B(ll x,int i){return (x>>i)&1;}int main(){	int N;	scanf("%d",&N);	ll o = 0;	vector<ll> vs;	rep(i,N){		ll x,y;		scanf("%lld%lld",&x,&y);		o ^= x;		vs.pb(x^y);	}	mat A(60);	rep(i,N){		rep(j,60){			A[j][i] = B(vs[i],j);		}	}	vector<bool> b(60);	rep(j,60) b[j] = B(o,j);	int r = getrank(A,b,N);	if(r == -1){		puts("1/1");		return 0;	}	cout << (1LL<<r)-1 << "/" << (1LL<<r) <<endl;}